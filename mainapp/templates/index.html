<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Center then Shift to Top</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      touch-action: none;
    }
    canvas { display: block; }
  </style>
</head>

<body>
  <script>
    let currentAngle = 0, targetAngle = 0;
    let csx = 0;
    let currentShiftX = 0, currentShiftY = 0;
    let prevTouchY = null;

    // Colors
    let BLACK, WHITE, GREY,
        RED, BLUE, GREEN,
        PURPLE, YELLOW, CYAN, ORANGE;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      angleMode(DEGREES);
      smooth();

      BLACK = color(0);
      WHITE = color(255);
      GREY  = color(100);
      RED   = color(255, 0, 0);
      BLUE  = color(25, 150, 255);
      GREEN = color(0, 255, 0);
      PURPLE= color(255, 0, 255);
      YELLOW= color(255, 255, 0);
      CYAN  = color(0, 255, 255);
      ORANGE= color(255, 100, 0);

      textAlign(CENTER, CENTER);
      textFont('Courier New');
    }

    function draw() {
      background(BLACK);

      // 1) sizing
      let bigR     = min(width, height) * 0.20;   // circle radius
      let smallR   = bigR * 0.05;                // dot radius
      let shiftX   = bigR * 1.0;                 // horizontal travel
      // compute upward travel so final center sits at bigR+margin
      let margin   = bigR * 0.5;
      let initialCY= height / 2;
      let topCY    = bigR + margin;
      let shiftY   = initialCY - topCY;          // positive value

      let labelSize = bigR * 0.5;
      let labelSize2 = bigR * 0.25;

      // 2) easing rotation & shifts
      currentAngle = lerp(currentAngle, targetAngle, 0.1);
      let doHoriz = currentAngle >= 137;
      let doVert  = currentAngle >= 165 && currentAngle <= 190;
      let py_sics_lable_side  = currentAngle >= 190;

      let ts = py_sics_lable_side? shiftX  : 0;
      let targetShiftX = doHoriz ? shiftX  : 0;
      // negative because we move _up_ by shiftY
      let targetShiftY = doVert||py_sics_lable_side  ? -shiftY : 0;

      csx = lerp(csx, ts, 0.1);
      currentShiftX = lerp(currentShiftX, targetShiftX, 0.1);
      currentShiftY = lerp(currentShiftY, targetShiftY, 0.1);

      // 3) draw at (width/2, height/2) plus current shifts
      push();
        translate(width/2 - currentShiftX, initialCY + currentShiftY);
        drawStructure(bigR, smallR);
      pop();

      // 4) label
      if (doHoriz) {
        push();
          translate(width/2 + currentShiftX, initialCY + currentShiftY);
          drawLabel(labelSize);
        pop();
        
      }
      if (doVert){
        push();
          translate(width/2 + currentShiftX, initialCY - currentShiftY-bigR);
          draw_python_physics(labelSize2);
        pop();
      }
      if (py_sics_lable_side){
        push();
          translate(width/2 - csx-30, initialCY - currentShiftY-bigR);
          draw_python_physics(labelSize2);
        pop();
      }
    }

    function drawStructure(BIG_RADIUS, SMALL_RADIUS) {
      // cap angle for geometry
      let c = constrain(currentAngle, 0, 137);

      noFill();
      stroke(WHITE);
      strokeWeight(3);
      ellipse(0, 0, BIG_RADIUS * 2);

      // crosshairs
      stroke(GREY);
      line(-BIG_RADIUS, 0, BIG_RADIUS, 0);
      line(0, -BIG_RADIUS, 0, BIG_RADIUS);

      // moving point
      let px = BIG_RADIUS * cos(-c),
          py = BIG_RADIUS * sin(-c);

      // radius
      stroke(RED);
      line(0, 0, px, py);

      // legs & extras
      stroke(PURPLE);
      line(0, py, px, py);

      stroke(GREEN);
      line(px, 0, px, py);

      stroke(YELLOW);
      line(BIG_RADIUS * (1 / cos(c)), 0, px, py);

      stroke(CYAN);
      line(0, -BIG_RADIUS * (1 / sin(c)), px, py);

      stroke(ORANGE);
      line(0, -BIG_RADIUS * (1 / sin(c)), 0, 0);

      stroke(BLUE);
      line(BIG_RADIUS * (1 / cos(c)), 0, 0, 0);

      // dot
      noStroke();
      fill(WHITE);
      ellipse(px, py, SMALL_RADIUS * 2);
    }

    function drawLabel(size) {
      const label  = 'Pysics';
      const colors = [GREEN, PURPLE, YELLOW, CYAN, BLUE, ORANGE];
      textSize(size);

      let totalW = 0;
      for (let ch of label) totalW += textWidth(ch);
      let x = -totalW/2, y = 0;

      for (let i = 0; i < label.length; i++) {
        fill(colors[i % colors.length]);
        let ch = label[i];
        text(ch, x + textWidth(ch)/2, y);
        x += textWidth(ch);
      }
    }

    function draw_python_physics(size){
      const label  = 'Python+Physics';
      const colors = [GREEN, PURPLE, YELLOW, CYAN, BLUE, ORANGE];
      textSize(size);

      let totalW = 0;
      for (let ch of label) totalW += textWidth(ch);
      let x = -totalW/2, y = 0;

      for (let i = 0; i < label.length; i++) {
        fill(colors[i % colors.length]);
        let ch = label[i];
        text(ch, x + textWidth(ch)/2, y);
        x += textWidth(ch);
      }
    }

    function mouseWheel(e) {
      targetAngle += e.delta * 0.1;
      return false;
    }
    function touchStarted() {
      prevTouchY = touches[0].y;
      return false;
    }
    function touchMoved() {
      let y = touches[0].y;
      targetAngle += (y - prevTouchY) * 0.1;
      prevTouchY = y;
      return false;
    }
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>

</html>
